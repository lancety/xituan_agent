# æ‰“å°æ¨¡æ¿ç³»ç»Ÿç»„ä»¶æ¶æ„

## ğŸ—ï¸ ç»„ä»¶æ¶æ„æ¦‚è§ˆ

### æ•´ä½“æ¶æ„å›¾
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CMSé¡µé¢å±‚                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  PrintTempList  â”‚  PrintTempEditor  â”‚  PrintTempPreview â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   ç»„ä»¶å±‚                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Canvas  â”‚  PropertyPanel  â”‚  DataBinding  â”‚  StyleEdit â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   å·¥å…·å±‚                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Renderer  â”‚  DataBinding  â”‚  EntityFields  â”‚  Utils   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   ç±»å‹å±‚                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  PrintTemp  â”‚  Element  â”‚  DataBinding  â”‚  Styles     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“ å®é™…æ–‡ä»¶ç»“æ„

### CMSå‰ç«¯ç»“æ„
```
xituan_cms/src/
â”œâ”€â”€ pages/printTemps/
â”‚   â”œâ”€â”€ index.tsx                    # æ‰“å°æ¨¡æ¿åˆ—è¡¨é¡µ
â”‚   â”œâ”€â”€ editor.tsx                   # æ‰“å°æ¨¡æ¿ç¼–è¾‘å™¨é¡µ
â”‚   â””â”€â”€ statistics.tsx               # æ¨¡æ¿ç»Ÿè®¡é¡µ
â”œâ”€â”€ components/printTemps/
â”‚   â”œâ”€â”€ TemplateCanvas.tsx           # ç”»å¸ƒç»„ä»¶
â”‚   â”œâ”€â”€ ElementPalette.tsx           # å…ƒç´ å·¥å…·æ 
â”‚   â”œâ”€â”€ ElementProperties.tsx        # å…ƒç´ å±æ€§é¢æ¿
â”‚   â”œâ”€â”€ TemplatePreviewSelector.tsx  # æ¨¡æ¿é¢„è§ˆé€‰æ‹©å™¨
â”‚   â””â”€â”€ PrintTempPreview.tsx         # æ‰“å°é¢„è§ˆç»„ä»¶
â”œâ”€â”€ componentsPrint/
â”‚   â””â”€â”€ TemplateBatchPrinter.tsx     # é€šç”¨æ‰¹é‡æ‰“å°ç»„ä»¶ï¼ˆé›†æˆprintTempsï¼‰
â”œâ”€â”€ lib/api/
â”‚   â””â”€â”€ printTemp.api.ts             # APIæ¥å£å°è£…
â”œâ”€â”€ utils/
â”‚   â””â”€â”€ templateRenderer.util.ts     # å‰ç«¯æ¨¡æ¿æ¸²æŸ“å™¨
â””â”€â”€ submodules/xituan_codebase/
    â””â”€â”€ typing_entity/
        â”œâ”€â”€ printTemp.type.ts        # æ‰“å°æ¨¡æ¿ç±»å‹å®šä¹‰
        â””â”€â”€ entityFields.default.ts  # å®ä½“å­—æ®µå®šä¹‰
```

### åç«¯ç»“æ„
```
xituan_backend/src/domains/printTemps/
â”œâ”€â”€ controllers/
â”‚   â”œâ”€â”€ printTemp.controller.ts      # æ‰“å°æ¨¡æ¿æ§åˆ¶å™¨
â”‚   â””â”€â”€ entityFields.controller.ts   # å®ä½“å­—æ®µæ§åˆ¶å™¨
â”œâ”€â”€ services/
â”‚   â””â”€â”€ printTemp.service.ts         # æ‰“å°æ¨¡æ¿æœåŠ¡
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ printTemp.routes.ts          # æ‰“å°æ¨¡æ¿è·¯ç”±
â”‚   â””â”€â”€ entityFields.routes.ts       # å®ä½“å­—æ®µè·¯ç”±
â””â”€â”€ submodules/xituan_codebase/
    â””â”€â”€ typing_entity/
        â”œâ”€â”€ printTemp.type.ts        # æ‰“å°æ¨¡æ¿ç±»å‹å®šä¹‰
        â””â”€â”€ entityFields.default.ts  # å®ä½“å­—æ®µå®šä¹‰
```

### æ•°æ®åº“ç»“æ„
```
xituan_backend/migrations/
â””â”€â”€ 1710000000150_create_print_temps_tables.sql  # æ•°æ®åº“è¿ç§»æ–‡ä»¶
```

## ğŸ¨ æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 1. æ‰“å°æ¨¡æ¿ç¼–è¾‘å™¨é¡µé¢ (editor.tsx)

```typescript
// pages/printTemps/editor.tsx
export default function PrintTempEditorPage() {
  const router = useRouter();
  const [template, setTemplate] = useState<iPrintTemp | null>(null);
  const [selectedElement, setSelectedElement] = useState<string | null>(null);
  const [sampleData, setSampleData] = useState<any>(null);
  const [entityFields, setEntityFields] = useState<iEntityField[]>([]);
  const [loading, setLoading] = useState(false);
  const [isDirty, setIsDirty] = useState(false);

  // ç¼–è¾‘å™¨å¸ƒå±€
  return (
    <MainLayout>
      <div className="print-temp-editor">
        {/* é¡¶éƒ¨å·¥å…·æ  */}
        <div className="editor-toolbar">
          <Space>
            <Button icon={<SaveOutlined />} onClick={handleSave}>
              ä¿å­˜
            </Button>
            <Button icon={<EyeOutlined />} onClick={handlePreview}>
              é¢„è§ˆ
            </Button>
            <Button icon={<UndoOutlined />} onClick={handleUndo}>
              æ’¤é”€
            </Button>
            <Button icon={<RedoOutlined />} onClick={handleRedo}>
              é‡åš
            </Button>
          </Space>
        </div>

        <Row gutter={16} style={{ height: 'calc(100vh - 120px)' }}>
          {/* å·¦ä¾§å…ƒç´ å·¥å…·æ  */}
          <Col span={4}>
            <ElementPalette
              onAddElement={handleAddElement}
              entityType={template?.entityType}
            />
          </Col>

          {/* ä¸­é—´ç”»å¸ƒåŒºåŸŸ */}
          <Col span={14}>
            <TemplateCanvas
              template={template}
              selectedElement={selectedElement}
              sampleData={sampleData}
              onSelectElement={setSelectedElement}
              onUpdateElement={handleUpdateElement}
              onDeleteElement={handleDeleteElement}
              onUpdateTemplate={setTemplate}
            />
          </Col>

          {/* å³ä¾§å±æ€§é¢æ¿ */}
          <Col span={6}>
            <ElementProperties
              element={selectedElement ? template?.elements.find(el => el.id === selectedElement) : null}
              entityFields={entityFields}
              sampleData={sampleData}
              onUpdateElement={handleUpdateElement}
              templateId={template?.id}
            />
          </Col>
        </Row>
      </div>
    </MainLayout>
  );
}
```

### 2. TemplateCanvas (ç”»å¸ƒç»„ä»¶)

```typescript
// components/printTemps/TemplateCanvas.tsx
interface TemplateCanvasProps {
  template: iPrintTemp | null;
  selectedElement: string | null;
  sampleData: any;
  onSelectElement: (elementId: string) => void;
  onUpdateElement: (elementId: string, updates: Partial<iPrintTempElement>) => void;
  onDeleteElement: (elementId: string) => void;
  onUpdateTemplate?: (template: iPrintTemp) => void;
}

export function TemplateCanvas({
  template,
  selectedElement,
  sampleData,
  onSelectElement,
  onUpdateElement,
  onDeleteElement,
  onUpdateTemplate
}: TemplateCanvasProps) {
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState<{ x: number; y: number } | null>(null);
  
  // å°ºå¯¸è½¬æ¢å·¥å…· (mm to px)
  const mmToPx = useCallback((mm: number) => mm * 3.78, []);
  
  // ç”»å¸ƒæ ·å¼
  const canvasStyle: React.CSSProperties = useMemo(() => {
    if (!template) return {};
    
    return {
      width: `${mmToPx(template.size.width)}px`,
      height: `${mmToPx(template.size.height)}px`,
      border: '1px solid #ccc',
      position: 'relative',
      backgroundColor: 'white',
      cursor: isDragging ? 'grabbing' : 'grab',
      margin: '0 auto'
    };
  }, [template, mmToPx, isDragging]);
  
  // å¤„ç†å…ƒç´ æ‹–æ‹½
  const handleElementMouseDown = useCallback((e: React.MouseEvent, elementId: string) => {
    e.stopPropagation();
    onSelectElement(elementId);
    setIsDragging(true);
    setDragStart({ x: e.clientX, y: e.clientY });
  }, [onSelectElement]);
  
  // å¤„ç†å…ƒç´ ç§»åŠ¨
  const handleElementMouseMove = useCallback((e: React.MouseEvent, elementId: string) => {
    if (!isDragging || !dragStart || !template) return;
    
    const deltaX = e.clientX - dragStart.x;
    const deltaY = e.clientY - dragStart.y;
    
    const element = template.elements.find(el => el.id === elementId);
    if (!element) return;
    
    const newX = element.position.x + (deltaX / mmToPx(1));
    const newY = element.position.y + (deltaY / mmToPx(1));
    
    onUpdateElement(elementId, {
      position: { x: Math.max(0, newX), y: Math.max(0, newY) }
    });
    
    setDragStart({ x: e.clientX, y: e.clientY });
  }, [isDragging, dragStart, template, mmToPx, onUpdateElement]);
  
  const handleMouseUp = useCallback(() => {
    setIsDragging(false);
    setDragStart(null);
  }, []);
  
  if (!template) {
    return (
      <div className="canvas-container">
        <div className="canvas-placeholder">
          è¯·é€‰æ‹©æˆ–åˆ›å»ºæ¨¡æ¿
        </div>
      </div>
    );
  }
  
  return (
    <div className="canvas-container">
      <div
        className="canvas"
        style={canvasStyle}
        onMouseUp={handleMouseUp}
      >
        {template.elements.map(element => (
          <div
            key={element.id}
            className={`element ${selectedElement === element.id ? 'selected' : ''}`}
            style={{
              position: 'absolute',
              left: `${mmToPx(element.position.x)}px`,
              top: `${mmToPx(element.position.y)}px`,
              width: `${mmToPx(element.size.width)}px`,
              height: `${mmToPx(element.size.height)}px`,
              border: selectedElement === element.id ? '2px solid #1890ff' : '1px solid transparent',
              cursor: 'pointer',
              zIndex: element.zIndex,
              ...element.styles
            }}
            onMouseDown={(e) => handleElementMouseDown(e, element.id)}
            onMouseMove={(e) => handleElementMouseMove(e, element.id)}
          >
            {/* å…ƒç´ å†…å®¹æ¸²æŸ“ */}
            <ElementContent
              element={element}
              sampleData={sampleData}
            />
          </div>
        ))}
      </div>
      
      <div className="canvas-info">
        {template.size.width}mm Ã— {template.size.height}mm
      </div>
    </div>
  );
}
```

### 3. ElementPalette (å…ƒç´ å·¥å…·æ )

```typescript
// components/printTemps/ElementPalette.tsx
interface ElementPaletteProps {
  onAddElement: (elementType: epPrintTempElementType) => void;
  entityType?: epEntityType;
}

export function ElementPalette({ onAddElement, entityType }: ElementPaletteProps) {
  const elementTypes = [
    { type: 'text', label: 'æ–‡æœ¬', icon: 'ğŸ“' },
    { type: 'barcode', label: 'æ¡å½¢ç ', icon: 'ğŸ“Š' },
    { type: 'image', label: 'å›¾ç‰‡', icon: 'ğŸ–¼ï¸' },
    { type: 'shape', label: 'å½¢çŠ¶', icon: 'ğŸ”·' }
  ];

  return (
    <Card title="å…ƒç´ å·¥å…·æ " size="small">
      <div className="element-palette">
        {elementTypes.map(({ type, label, icon }) => (
          <Button
            key={type}
            type="dashed"
            block
            style={{ marginBottom: 8 }}
            onClick={() => onAddElement(type as epPrintTempElementType)}
            icon={<span>{icon}</span>}
          >
            {label}
          </Button>
        ))}
      </div>
    </Card>
  );
}
```

### 4. ElementProperties (å…ƒç´ å±æ€§é¢æ¿)

```typescript
// components/printTemps/ElementProperties.tsx
interface ElementPropertiesProps {
  element: iPrintTempElement | null;
  entityFields: iEntityField[];
  sampleData: any;
  onUpdateElement: (elementId: string, updates: Partial<iPrintTempElement>) => void;
  templateId?: string;
  activeTab?: string;
  onTabChange?: (tab: string) => void;
}

export function ElementProperties({ 
  element, 
  entityFields, 
  sampleData, 
  onUpdateElement,
  templateId,
  activeTab: externalActiveTab,
  onTabChange
}: ElementPropertiesProps) {
  const [activeTab, setActiveTab] = useState('data');

  const handleTabChange = (tab: string) => {
    setActiveTab(tab);
    onTabChange?.(tab);
  };

  if (!element) {
    return (
      <Card title="å…ƒç´ å±æ€§" size="small">
        <Empty description="è¯·é€‰æ‹©ä¸€ä¸ªå…ƒç´ " />
      </Card>
    );
  }

  return (
    <Card title="å…ƒç´ å±æ€§" size="small">
      <Tabs
        activeKey={externalActiveTab || activeTab}
        onChange={handleTabChange}
        items={[
          {
            key: 'data',
            label: 'æ•°æ®ç»‘å®š',
            children: (
              <DataBindingEditor
                element={element}
                entityFields={entityFields}
                onUpdateElement={onUpdateElement}
              />
            )
          },
          {
            key: 'style',
            label: 'æ ·å¼è®¾ç½®',
            children: (
              <StyleEditor
                element={element}
                onUpdateElement={onUpdateElement}
              />
            )
          },
          {
            key: 'layout',
            label: 'å¸ƒå±€è®¾ç½®',
            children: (
              <LayoutEditor
                element={element}
                onUpdateElement={onUpdateElement}
              />
            )
          }
        ]}
      />
    </Card>
  );
}
```

### 5. TemplateBatchPrinter (é€šç”¨æ‰¹é‡æ‰“å°ç»„ä»¶)

```typescript
// componentsPrint/TemplateBatchPrinter.tsx
interface iPrintItem<T> {
  item: T;                                    // åŸå§‹å®ä½“å¯¹è±¡
  quantity: number;
  selected?: boolean;                         // ä»…ç”¨äº printItems
  sourceIndex?: number;                       // printItemsSource ä¸­çš„ç´¢å¼•
  id: string;                                 // æ˜¾ç¤ºç”¨çš„ID
  name: iMultilingualContent | string;        // æ˜¾ç¤ºç”¨çš„åç§°
}

interface iTemplateBatchPrinterProps<T> {
  visible: boolean;
  onClose: () => void;
  printItemsSource: iPrintItem<T>[];
  entityType: epEntityType;
}

export function TemplateBatchPrinter<T>({
  visible,
  onClose,
  printItemsSource,
  entityType
}: iTemplateBatchPrinterProps<T>) {
  const [printItems, setPrintItems] = useState<iPrintItem<T>[]>([]);
  const [selectedTemplate, setSelectedTemplate] = useState<iPrintTemp | null>(null);
  const [labelLanguage, setLabelLanguage] = useState<string>('zh_cn');
  const [startDate, setStartDate] = useState<dayjs.Dayjs>(dayjs());

  // åˆå§‹åŒ–æ‰“å°é¡¹ç›®
  React.useEffect(() => {
    if (visible && printItemsSource.length > 0) {
      const items: iPrintItem<T>[] = printItemsSource.map((printItem, index) => ({
        item: printItem.item,
        quantity: printItem.quantity,
        sourceIndex: index,
        id: printItem.id,
        name: printItem.name,
        selected: true // é»˜è®¤å…¨é€‰
      }));
      setPrintItems(items);
    }
  }, [visible, printItemsSource]);

  // å¤„ç†é€‰æ‹©å˜åŒ–
  const handleSelectChange = useCallback((sourceIndex: number, checked: boolean) => {
    setPrintItems(prev => prev.map(item => 
      item.sourceIndex === sourceIndex 
        ? { ...item, selected: checked }
        : item
    ));
  }, []);

  // å¤„ç†æ•°é‡å˜åŒ–
  const handleQuantityChange = useCallback((sourceIndex: number, quantity: number) => {
    setPrintItems(prev => prev.map(item => 
      item.sourceIndex === sourceIndex 
        ? { ...item, quantity }
        : item
    ));
  }, []);

  // é‡ç½®æ‰€æœ‰é¡¹ç›®
  const handleReset = useCallback(() => {
    setPrintItems(prev => prev.map(item => ({
      item: item.item,
      quantity: printItemsSource[item.sourceIndex!]?.quantity || item.quantity,
      sourceIndex: item.sourceIndex,
      id: item.id,
      name: item.name,
      selected: true
    })));
  }, [printItemsSource]);

  // æ‰¹é‡æ‰“å°
  const handleBatchPrint = useCallback(async () => {
    const selectedItems = printItems.filter(item => item.selected);
    
    if (selectedItems.length === 0) {
      message.warning('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªé¡¹ç›®è¿›è¡Œæ‰“å°');
      return;
    }

    if (!selectedTemplate) {
      message.warning('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ‰“å°æ¨¡æ¿');
      return;
    }

    // ç”Ÿæˆæ‰“å°é¡µé¢
    const printPages: { [key: string]: T }[] = [];
    selectedItems.forEach(item => {
      for (let i = 0; i < item.quantity; i++) {
        printPages.push({
          [entityType.toLowerCase()]: item.item
        });
      }
    });

    // æ‰§è¡Œæ‰“å°
    await printAllLabels(printPages);
  }, [printItems, selectedTemplate, entityType]);

  // è¡¨æ ¼åˆ—å®šä¹‰
  const columns = [
    {
      title: 'é€‰æ‹©',
      key: 'selected',
      width: 60,
      render: (record: iPrintItem<T>) => (
        <Checkbox
          checked={record.selected}
          onChange={(e) => handleSelectChange(record.sourceIndex!, e.target.checked)}
        />
      ),
    },
    {
      title: 'å®ä½“åç§°',
      key: 'entityName',
      render: (record: iPrintItem<T>) => (
        <span>
          {typeof record.name === 'string' 
            ? record.name 
            : multilingualUtil.getLocalizedText(record.name, language, ['zh_cn', 'en'])
          }
        </span>
      ),
    },
    {
      title: 'æ•°é‡',
      key: 'quantity',
      width: 100,
      render: (record: iPrintItem<T>) => (
        <InputNumber
          min={1}
          max={999}
          value={record.quantity}
          onChange={(value) => handleQuantityChange(record.sourceIndex!, value || 1)}
          style={{ width: '100%' }}
        />
      ),
    },
  ];

  return (
    <Modal
      title="æ‰¹é‡æ‰“å°æ ‡ç­¾"
      open={visible}
      onCancel={onClose}
      width={1200}
      footer={[
        <Button key="reset" icon={<ReloadOutlined />} onClick={handleReset}>
          é‡ç½®
        </Button>,
        <Button key="print" type="primary" icon={<PrinterOutlined />} onClick={handleBatchPrint}>
          æ‰¹é‡æ‰“å°
        </Button>,
      ]}
    >
      <Tabs
        items={[
          {
            key: 'config',
            label: 'é…ç½®é€‰é¡¹',
            children: (
              <>
                <Table
                  columns={columns}
                  dataSource={printItems}
                  rowKey={(record) => record.sourceIndex!}
                  pagination={false}
                  size="small"
                />
                
                {/* é…ç½®é€‰é¡¹ */}
                <Row gutter={16} style={{ marginTop: 16 }}>
                  <Col span={12}>
                    <Select
                      value={labelLanguage}
                      onChange={setLabelLanguage}
                      style={{ width: '100%' }}
                    >
                      <Select.Option value="zh_cn">ç®€ä½“ä¸­æ–‡</Select.Option>
                      <Select.Option value="en">English</Select.Option>
                    </Select>
                  </Col>
                  <Col span={12}>
                    <DatePicker
                      value={startDate}
                      onChange={(date) => setStartDate(date || dayjs())}
                      style={{ width: '100%' }}
                      format="YYYY-MM-DD"
                    />
                  </Col>
                </Row>
              </>
            )
          },
          {
            key: 'template',
            label: 'é€‰æ‹©æ¨¡æ¿',
            children: (
              <TemplatePreviewSelector
                entityType={entityType}
                sampleData={printItemsSource[0]?.item || null}
                language={labelLanguage}
                selectedTemplateId={selectedTemplate?.id}
                onTemplateSelect={setSelectedTemplate}
                visible={true}
              />
            )
          }
        ]}
      />
    </Modal>
  );
}
```

### 6. TemplatePreviewSelector (æ¨¡æ¿é¢„è§ˆé€‰æ‹©å™¨)

```typescript
// components/printTemps/TemplatePreviewSelector.tsx
interface TemplatePreviewSelectorProps {
  entityType?: epEntityType;
  sampleData?: any;
  language?: string;
  selectedTemplateId?: string;
  onTemplateSelect: (template: iPrintTemp) => void;
  visible?: boolean;
  onClose?: () => void;
}

export function TemplatePreviewSelector({
  entityType,
  sampleData,
  language,
  selectedTemplateId,
  onTemplateSelect,
  visible = true,
  onClose
}: TemplatePreviewSelectorProps) {
  const [templates, setTemplates] = useState<iPrintTemp[]>([]);
  const [loading, setLoading] = useState(false);
  const [pagination, setPagination] = useState({
    page: 1,
    size: 12,
    total: 0,
    totalPages: 0
  });
  const [filters, setFilters] = useState({
    category: undefined as epPrintTempCategory | undefined,
    keyword: '',
    status: 'active' as 'active' | 'inactive'
  });

  // åŠ è½½æ¨¡æ¿åˆ—è¡¨
  const loadTemplates = useCallback(async (page = 1, reset = false) => {
    try {
      setLoading(true);

      const params: iPrintTempQueryParams = {
        entityType,
        category: filters.category,
        status: filters.status,
        keyword: filters.keyword || undefined,
        page,
        size: pagination.size,
        sortBy: 'created_at',
        sortOrder: 'desc'
      };

      const response: iPrintTempListResponse = await printTempApi.getPrintTemps(params);
      
      if (reset) {
        setTemplates(response.items);
      } else {
        setTemplates(prev => [...prev, ...response.items]);
      }
      
      setPagination(response.pagination);
    } catch (error) {
      console.error('åŠ è½½æ¨¡æ¿åˆ—è¡¨å¤±è´¥:', error);
      message.error('åŠ è½½æ¨¡æ¿å¤±è´¥');
    } finally {
      setLoading(false);
    }
  }, [entityType, filters, pagination.size]);

  // æ¨¡æ¿é¢„è§ˆå¡ç‰‡
  const TemplatePreviewCard: React.FC<{ template: iPrintTemp }> = ({ template }) => {
    const [previewHtml, setPreviewHtml] = useState<string>('');
    const [previewLoading, setPreviewLoading] = useState(false);

    useEffect(() => {
      if (sampleData) {
        setPreviewLoading(true);
        try {
          const rendered = frontendTemplateRenderer.renderTemplate(template, sampleData, language);
          setPreviewHtml(rendered.html);
        } catch (error) {
          console.error('æ¨¡æ¿é¢„è§ˆå¤±è´¥:', error);
        } finally {
          setPreviewLoading(false);
        }
      }
    }, [template, sampleData, language]);

    return (
      <Card
        hoverable
        size="small"
        className={`template-preview-card ${selectedTemplateId === template.id ? 'selected' : ''}`}
        onClick={() => onTemplateSelect(template)}
        actions={[
          <EyeOutlined key="preview" title="é¢„è§ˆ" />,
          <CheckOutlined key="select" title="é€‰æ‹©" />
        ]}
      >
        <div className="template-preview">
          <div className="template-info">
            <div className="template-name">{template.name}</div>
            <div className="template-category">
              <Tag color="blue">{printTempCategoryNames[template.category]}</Tag>
            </div>
            <div className="template-size">
              {template.size.width}mm Ã— {template.size.height}mm
            </div>
          </div>
          
          <div className="template-preview-content">
            {previewLoading ? (
              <Spin size="small" />
            ) : (
              <div 
                className="preview-html"
                dangerouslySetInnerHTML={{ __html: previewHtml }}
                style={{
                  transform: 'scale(0.3)',
                  transformOrigin: 'top left',
                  width: '333%',
                  height: '333%'
                }}
              />
            )}
          </div>
        </div>
      </Card>
    );
  };

  return (
    <Modal
      title="é€‰æ‹©æ‰“å°æ¨¡æ¿"
      open={visible}
      onCancel={onClose}
      width={1200}
      footer={null}
    >
      <div className="template-selector">
        {/* ç­›é€‰å™¨ */}
        <div className="template-filters">
          <Space wrap>
            <Select
              placeholder="é€‰æ‹©åˆ†ç±»"
              value={filters.category}
              onChange={(value) => setFilters(prev => ({ ...prev, category: value }))}
              allowClear
              style={{ width: 150 }}
            >
              {Object.entries(printTempCategoryNames).map(([key, label]) => (
                <Option key={key} value={key}>{label}</Option>
              ))}
            </Select>
            
            <Search
              placeholder="æœç´¢æ¨¡æ¿"
              value={filters.keyword}
              onChange={(e) => setFilters(prev => ({ ...prev, keyword: e.target.value }))}
              onSearch={() => loadTemplates(1, true)}
              style={{ width: 200 }}
            />
            
            <Button 
              icon={<ReloadOutlined />} 
              onClick={() => loadTemplates(1, true)}
            >
              åˆ·æ–°
            </Button>
          </Space>
        </div>

        {/* æ¨¡æ¿åˆ—è¡¨ */}
        <div className="template-list">
          <Row gutter={[16, 16]}>
            {templates.map(template => (
              <Col key={template.id} span={6}>
                <TemplatePreviewCard template={template} />
              </Col>
            ))}
          </Row>
          
          {loading && (
            <div className="loading-container">
              <Spin size="large" />
            </div>
          )}
          
          {!loading && templates.length === 0 && (
            <Empty description="æš‚æ— æ¨¡æ¿" />
          )}
        </div>
      </div>
    </Modal>
  );
}
```

### 5. StyleEditor (æ ·å¼ç¼–è¾‘å™¨)

```typescript
// components/printTemps/editors/StyleEditor.tsx
interface iStyleEditorProps {
  element: iPrintTempElement | null;
  onUpdate: (updates: Partial<iPrintTempElement>) => void;
}

const StyleEditor: React.FC<iStyleEditorProps> = ({
  element,
  onUpdate
}) => {
  const [fontFamily, setFontFamily] = useState('Arial');
  const [fontSize, setFontSize] = useState(12);
  const [color, setColor] = useState('#000000');
  
  // å­—ä½“é€‰é¡¹
  const fontOptions = [
    { value: 'Arial', label: 'Arial' },
    { value: 'Bahnschrift SemiBold Condensed', label: 'Bahnschrift SemiBold Condensed' },
    { value: 'Helvetica', label: 'Helvetica' },
    { value: 'Times New Roman', label: 'Times New Roman' },
    { value: 'Courier New', label: 'Courier New' }
  ];
  
  // å¤„ç†æ ·å¼æ›´æ–°
  const handleStyleUpdate = useCallback((styleKey: string, value: any) => {
    if (!element) return;
    
    onUpdate({
      styles: {
        ...element.styles,
        [styleKey]: value
      }
    });
  }, [element, onUpdate]);
  
  if (!element) {
    return (
      <div className="style-editor">
        <div className="no-selection">è¯·é€‰æ‹©ä¸€ä¸ªå…ƒç´ </div>
      </div>
    );
  }
  
  return (
    <div className="style-editor">
      <Form layout="vertical">
        {/* å­—ä½“è®¾ç½® */}
        <Form.Item label="å­—ä½“">
          <Select
            value={element.styles.fontFamily}
            onChange={(value) => handleStyleUpdate('fontFamily', value)}
            options={fontOptions}
          />
        </Form.Item>
        
        <Form.Item label="å­—ä½“å¤§å°">
          <InputNumber
            value={element.styles.fontSize}
            onChange={(value) => handleStyleUpdate('fontSize', value)}
            min={6}
            max={72}
            addonAfter="px"
          />
        </Form.Item>
        
        <Form.Item label="å­—ä½“ç²—ç»†">
          <Select
            value={element.styles.fontWeight}
            onChange={(value) => handleStyleUpdate('fontWeight', value)}
            options={[
              { value: 'normal', label: 'æ­£å¸¸' },
              { value: 'bold', label: 'ç²—ä½“' },
              { value: 'lighter', label: 'ç»†ä½“' },
              { value: 'bolder', label: 'æ›´ç²—' }
            ]}
          />
        </Form.Item>
        
        <Form.Item label="å­—ä½“æ ·å¼">
          <Checkbox.Group
            value={[
              element.styles.fontStyle === 'italic' ? 'italic' : null,
              element.styles.textDecoration === 'underline' ? 'underline' : null
            ].filter(Boolean)}
            onChange={(values) => {
              handleStyleUpdate('fontStyle', values.includes('italic') ? 'italic' : 'normal');
              handleStyleUpdate('textDecoration', values.includes('underline') ? 'underline' : 'none');
            }}
          >
            <Checkbox value="italic">æ–œä½“</Checkbox>
            <Checkbox value="underline">ä¸‹åˆ’çº¿</Checkbox>
          </Checkbox.Group>
        </Form.Item>
        
        {/* é¢œè‰²è®¾ç½® */}
        <Form.Item label="æ–‡å­—é¢œè‰²">
          <ColorPicker
            value={element.styles.color}
            onChange={(color) => handleStyleUpdate('color', color.toHexString())}
          />
        </Form.Item>
        
        <Form.Item label="èƒŒæ™¯é¢œè‰²">
          <ColorPicker
            value={element.styles.backgroundColor}
            onChange={(color) => handleStyleUpdate('backgroundColor', color.toHexString())}
          />
        </Form.Item>
        
        {/* å¯¹é½è®¾ç½® */}
        <Form.Item label="æ°´å¹³å¯¹é½">
          <Radio.Group
            value={element.styles.textAlign}
            onChange={(e) => handleStyleUpdate('textAlign', e.target.value)}
          >
            <Radio value="left">å·¦å¯¹é½</Radio>
            <Radio value="center">å±…ä¸­</Radio>
            <Radio value="right">å³å¯¹é½</Radio>
            <Radio value="justify">ä¸¤ç«¯å¯¹é½</Radio>
          </Radio.Group>
        </Form.Item>
        
        <Form.Item label="å‚ç›´å¯¹é½">
          <Radio.Group
            value={element.styles.verticalAlign}
            onChange={(e) => handleStyleUpdate('verticalAlign', e.target.value)}
          >
            <Radio value="top">é¡¶éƒ¨</Radio>
            <Radio value="middle">å±…ä¸­</Radio>
            <Radio value="bottom">åº•éƒ¨</Radio>
          </Radio.Group>
        </Form.Item>
        
        {/* é—´è·è®¾ç½® */}
        <Form.Item label="è¡Œé«˜">
          <InputNumber
            value={element.styles.lineHeight}
            onChange={(value) => handleStyleUpdate('lineHeight', value)}
            min={0.5}
            max={3}
            step={0.1}
          />
        </Form.Item>
        
        <Form.Item label="å­—é—´è·">
          <InputNumber
            value={element.styles.letterSpacing}
            onChange={(value) => handleStyleUpdate('letterSpacing', value)}
            min={-2}
            max={10}
            addonAfter="px"
          />
        </Form.Item>
        
        <Form.Item label="è¯é—´è·">
          <InputNumber
            value={element.styles.wordSpacing}
            onChange={(value) => handleStyleUpdate('wordSpacing', value)}
            min={-2}
            max={10}
            addonAfter="px"
          />
        </Form.Item>
      </Form>
    </div>
  );
};
```

## ğŸ”§ å·¥å…·å‡½æ•°å’ŒHooks

### 1. usePrintTempEditor Hook

```typescript
// hooks/printTemps/usePrintTempEditor.ts
interface iUsePrintTempEditorProps {
  printTempId?: string;
  entityType: epEntityType;
  onPrintTempChange: (printTemp: iPrintTemp) => void;
  onDirtyChange: (isDirty: boolean) => void;
}

export const usePrintTempEditor = ({
  printTempId,
  entityType,
  onPrintTempChange,
  onDirtyChange
}: iUsePrintTempEditorProps) => {
  const [printTemp, setPrintTemp] = useState<iPrintTemp | undefined>();
  const [isLoading, setIsLoading] = useState(false);
  const [isDirty, setIsDirty] = useState(false);
  
  // åŠ è½½æ¨¡æ¿
  const loadPrintTemp = useCallback(async () => {
    if (!printTempId) return;
    
    setIsLoading(true);
    try {
      const response = await api.getPrintTemp(printTempId);
      setPrintTemp(response.data);
      onPrintTempChange(response.data);
    } catch (error) {
      console.error('Failed to load print temp:', error);
    } finally {
      setIsLoading(false);
    }
  }, [printTempId, onPrintTempChange]);
  
  // åˆ›å»ºæ–°æ¨¡æ¿
  const createNewPrintTemp = useCallback(() => {
    const newPrintTemp: iPrintTemp = {
      id: generateId(),
      name: 'æ–°æ¨¡æ¿',
      description: '',
      category: 'custom_label',
      entityType,
      size: { width: 40, height: 30 },
      elements: [],
      requiredFields: [],
      optionalFields: [],
      version: 1,
      isActive: true,
      createdBy: getCurrentUserId(),
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    setPrintTemp(newPrintTemp);
    onPrintTempChange(newPrintTemp);
    setIsDirty(true);
  }, [entityType, onPrintTempChange]);
  
  // æ·»åŠ å…ƒç´ 
  const addElement = useCallback((elementType: epPrintTempElementType) => {
    if (!printTemp) return;
    
    const newElement: iPrintTempElement = {
      id: generateId(),
      type: elementType,
      position: { x: 10, y: 10 },
      size: { width: 20, height: 10 },
      dataBinding: { type: 'fixed', value: '' },
      styles: getDefaultElementStyles(elementType),
      zIndex: printTemp.elements.length + 1
    };
    
    const updatedPrintTemp = {
      ...printTemp,
      elements: [...printTemp.elements, newElement]
    };
    
    setPrintTemp(updatedPrintTemp);
    onPrintTempChange(updatedPrintTemp);
    setIsDirty(true);
  }, [printTemp, onPrintTempChange]);
  
  // åˆ é™¤å…ƒç´ 
  const removeElement = useCallback((elementId: string) => {
    if (!printTemp) return;
    
    const updatedPrintTemp = {
      ...printTemp,
      elements: printTemp.elements.filter(el => el.id !== elementId)
    };
    
    setPrintTemp(updatedPrintTemp);
    onPrintTempChange(updatedPrintTemp);
    setIsDirty(true);
  }, [printTemp, onPrintTempChange]);
  
  // æ›´æ–°å…ƒç´ 
  const updateElement = useCallback((elementId: string, updates: Partial<iPrintTempElement>) => {
    if (!printTemp) return;
    
    const updatedPrintTemp = {
      ...printTemp,
      elements: printTemp.elements.map(el => 
        el.id === elementId ? { ...el, ...updates } : el
      )
    };
    
    setPrintTemp(updatedPrintTemp);
    onPrintTempChange(updatedPrintTemp);
    setIsDirty(true);
  }, [printTemp, onPrintTempChange]);
  
  // ä¿å­˜æ¨¡æ¿
  const savePrintTemp = useCallback(async () => {
    if (!printTemp) return;
    
    try {
      if (printTempId) {
        await api.updatePrintTemp(printTempId, printTemp);
      } else {
        await api.createPrintTemp(printTemp);
      }
      setIsDirty(false);
    } catch (error) {
      console.error('Failed to save print temp:', error);
      throw error;
    }
  }, [printTemp, printTempId]);
  
  useEffect(() => {
    if (printTempId) {
      loadPrintTemp();
    } else {
      createNewPrintTemp();
    }
  }, [printTempId, loadPrintTemp, createNewPrintTemp]);
  
  useEffect(() => {
    onDirtyChange(isDirty);
  }, [isDirty, onDirtyChange]);
  
  return {
    printTemp,
    isLoading,
    isDirty,
    addElement,
    removeElement,
    updateElement,
    savePrintTemp
  };
};
```

### 2. useDataBinding Hook

```typescript
// hooks/printTemps/useDataBinding.ts
export const useDataBinding = () => {
  // æ•°æ®ç»‘å®šå¼•æ“
  const dataBindingEngine = useMemo(() => new DataBindingEngine(), []);
  
  // ç»‘å®šæ•°æ®
  const bindData = useCallback((
    element: iPrintTempElement,
    data: any,
    language: string = 'zh_cn'
  ): string => {
    return dataBindingEngine.bindData(element, data, language);
  }, [dataBindingEngine]);
  
  // éªŒè¯ç»‘å®šé…ç½®
  const validateBinding = useCallback((
    binding: iPrintTempDataBinding,
    entityType: epEntityType
  ): { isValid: boolean; errors: string[] } => {
    return dataBindingEngine.validateBinding(binding, entityType);
  }, [dataBindingEngine]);
  
  // è·å–ç»‘å®šé¢„è§ˆ
  const getBindingPreview = useCallback((
    element: iPrintTempElement,
    sampleData: any,
    language: string = 'zh_cn'
  ): string => {
    return dataBindingEngine.getPreview(element, sampleData, language);
  }, [dataBindingEngine]);
  
  return {
    bindData,
    validateBinding,
    getBindingPreview
  };
};
```

### 3. æ¨¡æ¿æ¸²æŸ“å™¨

```typescript
// utils/printTemps/templateRenderer.ts
export class TemplateRenderer {
  // æ¸²æŸ“æ¨¡æ¿
  renderTemplate(
    template: iPrintTemp,
    data: any,
    language: string = 'zh_cn'
  ): { html: string; css: string } {
    const css = this.generateCSS(template);
    const html = this.generateHTML(template, data, language);
    
    return { html, css };
  }
  
  // ç”ŸæˆCSS
  private generateCSS(template: iPrintTemp): string {
    const css = `
      .print-temp {
        width: ${template.size.width / 10}cm;
        height: ${template.size.height / 10}cm;
        position: relative;
        background: white;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }
      
      .print-temp-element {
        position: absolute;
        box-sizing: border-box;
      }
      
      ${template.elements.map(element => this.generateElementCSS(element)).join('\n')}
    `;
    
    return css;
  }
  
  // ç”ŸæˆHTML
  private generateHTML(
    template: iPrintTemp,
    data: any,
    language: string
  ): string {
    const elementsHtml = template.elements
      .sort((a, b) => a.zIndex - b.zIndex)
      .map(element => this.generateElementHTML(element, data, language))
      .join('\n');
    
    return `
      <div class="print-temp">
        ${elementsHtml}
      </div>
    `;
  }
  
  // ç”Ÿæˆå…ƒç´ CSS
  private generateElementCSS(element: iPrintTempElement): string {
    const { position, size, styles } = element;
    
    return `
      .element-${element.id} {
        left: ${position.x / 10}cm;
        top: ${position.y / 10}cm;
        width: ${size.width / 10}cm;
        height: ${size.height / 10}cm;
        font-family: ${styles.fontFamily};
        font-size: ${styles.fontSize}px;
        font-weight: ${styles.fontWeight};
        font-style: ${styles.fontStyle};
        text-align: ${styles.textAlign};
        vertical-align: ${styles.verticalAlign};
        line-height: ${styles.lineHeight};
        letter-spacing: ${styles.letterSpacing}px;
        word-spacing: ${styles.wordSpacing}px;
        color: ${styles.color};
        background-color: ${styles.backgroundColor};
        text-decoration: ${styles.textDecoration};
        text-shadow: ${styles.textShadow};
        padding: ${styles.padding.top / 10}cm ${styles.padding.right / 10}cm ${styles.padding.bottom / 10}cm ${styles.padding.left / 10}cm;
        margin: ${styles.margin.top / 10}cm ${styles.margin.right / 10}cm ${styles.margin.bottom / 10}cm ${styles.margin.left / 10}cm;
      }
    `;
  }
  
  // ç”Ÿæˆå…ƒç´ HTML
  private generateElementHTML(
    element: iPrintTempElement,
    data: any,
    language: string
  ): string {
    const content = this.bindElementData(element, data, language);
    
    return `
      <div class="print-temp-element element-${element.id}">
        ${content}
      </div>
    `;
  }
  
  // ç»‘å®šå…ƒç´ æ•°æ®
  private bindElementData(
    element: iPrintTempElement,
    data: any,
    language: string
  ): string {
    const { dataBinding } = element;
    
    switch (dataBinding.type) {
      case 'fixed':
        return dataBinding.value || '';
      case 'entity':
        return this.resolveEntityPath(dataBinding.entityPath || '', data, language);
      case 'date':
        return this.formatDate(dataBinding.dateTimeConfig, data);
      case 'time':
        return this.formatTime(dataBinding.dateTimeConfig, data);
      case 'calculated':
        return this.calculateValue(dataBinding.calculation, data);
      default:
        return '';
    }
  }
  
  // è§£æå®ä½“è·¯å¾„
  private resolveEntityPath(path: string, data: any, language: string): string {
    const value = get(data, path);
    
    if (value && typeof value === 'object' && value.intl) {
      return value[language] || value.zh_cn || value.en || '';
    }
    
    return String(value || '');
  }
  
  // æ ¼å¼åŒ–æ—¥æœŸ
  private formatDate(config: iPrintTempDateTimeConfig | undefined, data: any): string {
    if (!config) return '';
    
    let baseDate: Date;
    
    if (config.baseType === 'now') {
      baseDate = new Date();
    } else if (config.baseField) {
      const fieldValue = get(data, config.baseField);
      baseDate = new Date(fieldValue);
    } else {
      baseDate = new Date();
    }
    
    // åº”ç”¨åç§»
    if (config.shiftConfig) {
      const { shiftDays = 0, shiftHours = 0, shiftMinutes = 0 } = config.shiftConfig;
      baseDate.setDate(baseDate.getDate() + shiftDays);
      baseDate.setHours(baseDate.getHours() + shiftHours);
      baseDate.setMinutes(baseDate.getMinutes() + shiftMinutes);
    }
    
    return dayjs(baseDate).format(config.format);
  }
  
  // æ ¼å¼åŒ–æ—¶é—´
  private formatTime(config: iPrintTempDateTimeConfig | undefined, data: any): string {
    if (!config) return '';
    
    let baseTime: Date;
    
    if (config.baseType === 'now') {
      baseTime = new Date();
    } else if (config.baseField) {
      const fieldValue = get(data, config.baseField);
      baseTime = new Date(fieldValue);
    } else {
      baseTime = new Date();
    }
    
    // åº”ç”¨åç§»
    if (config.shiftConfig) {
      const { shiftHours = 0, shiftMinutes = 0, shiftSeconds = 0 } = config.shiftConfig;
      baseTime.setHours(baseTime.getHours() + shiftHours);
      baseTime.setMinutes(baseTime.getMinutes() + shiftMinutes);
      baseTime.setSeconds(baseTime.getSeconds() + shiftSeconds);
    }
    
    return dayjs(baseTime).format(config.format);
  }
  
  // è®¡ç®—å€¼
  private calculateValue(calculation: iPrintTempCalculation | undefined, data: any): string {
    if (!calculation) return '';
    
    switch (calculation.type) {
      case 'date_shift':
        return this.formatDate({
          baseType: 'entity_field',
          baseField: calculation.baseField,
          format: 'YYYY-MM-DD',
          shiftConfig: {
            shiftDays: calculation.shiftDays || 0
          }
        }, data);
      case 'time_shift':
        return this.formatTime({
          baseType: 'entity_field',
          baseField: calculation.baseField,
          format: 'HH:mm:ss',
          shiftConfig: {
            shiftHours: calculation.shiftHours || 0,
            shiftMinutes: calculation.shiftMinutes || 0
          }
        }, data);
      case 'formula':
        return this.evaluateFormula(calculation.formula || '', data);
      default:
        return '';
    }
  }
  
  // è®¡ç®—å…¬å¼
  private evaluateFormula(formula: string, data: any): string {
    try {
      // ç®€å•çš„å…¬å¼è®¡ç®—ï¼Œå®é™…é¡¹ç›®ä¸­éœ€è¦æ›´å®‰å…¨çš„å®ç°
      const result = eval(formula.replace(/\{(\w+)\}/g, (match, key) => {
        const value = get(data, key);
        return typeof value === 'number' ? value : 0;
      }));
      return String(result);
    } catch (error) {
      console.error('Formula evaluation error:', error);
      return '';
    }
  }
}
```

## ğŸ¯ ç»„ä»¶é€šä¿¡

### 1. çŠ¶æ€ç®¡ç†
```typescript
// stores/printTempsStore.ts
interface iPrintTempsState {
  printTemps: iPrintTemp[];
  currentPrintTemp: iPrintTemp | null;
  selectedElement: string | null;
  previewData: any;
  isLoading: boolean;
  error: string | null;
}

export const usePrintTempsStore = create<iPrintTempsState>((set, get) => ({
  printTemps: [],
  currentPrintTemp: null,
  selectedElement: null,
  previewData: null,
  isLoading: false,
  error: null,
  
  // Actions
  setCurrentPrintTemp: (printTemp: iPrintTemp | null) => 
    set({ currentPrintTemp: printTemp }),
  
  setSelectedElement: (elementId: string | null) => 
    set({ selectedElement: elementId }),
  
  setPreviewData: (data: any) => 
    set({ previewData: data }),
  
  updateElement: (elementId: string, updates: Partial<iPrintTempElement>) => {
    const state = get();
    if (!state.currentPrintTemp) return;
    
    const updatedPrintTemp = {
      ...state.currentPrintTemp,
      elements: state.currentPrintTemp.elements.map(el => 
        el.id === elementId ? { ...el, ...updates } : el
      )
    };
    
    set({ currentPrintTemp: updatedPrintTemp });
  }
}));
```

### 2. äº‹ä»¶ç³»ç»Ÿ
```typescript
// utils/printTemps/eventBus.ts
class PrintTempsEventBus {
  private events: Map<string, Function[]> = new Map();
  
  on(event: string, callback: Function) {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event)!.push(callback);
  }
  
  off(event: string, callback: Function) {
    if (!this.events.has(event)) return;
    
    const callbacks = this.events.get(event)!;
    const index = callbacks.indexOf(callback);
    if (index > -1) {
      callbacks.splice(index, 1);
    }
  }
  
  emit(event: string, ...args: any[]) {
    if (!this.events.has(event)) return;
    
    this.events.get(event)!.forEach(callback => {
      callback(...args);
    });
  }
}

export const printTempsEventBus = new PrintTempsEventBus();
```

## ğŸ”§ æ€§èƒ½ä¼˜åŒ–

### 1. ç»„ä»¶ä¼˜åŒ–
```typescript
// ä½¿ç”¨ React.memo ä¼˜åŒ–ç»„ä»¶
export const ElementRenderer = React.memo<iElementRendererProps>(({
  element,
  previewData,
  isSelected,
  onSelect,
  onUpdate,
  mmToPx
}) => {
  // ç»„ä»¶å®ç°
});

// ä½¿ç”¨ useMemo ä¼˜åŒ–è®¡ç®—
const elementStyle = useMemo(() => {
  return {
    position: 'absolute',
    left: `${mmToPx(element.position.x)}px`,
    top: `${mmToPx(element.position.y)}px`,
    // ... å…¶ä»–æ ·å¼
  };
}, [element.position, element.size, mmToPx]);

// ä½¿ç”¨ useCallback ä¼˜åŒ–å‡½æ•°
const handleElementUpdate = useCallback((elementId: string, updates: Partial<iPrintTempElement>) => {
  // æ›´æ–°é€»è¾‘
}, []);
```

### 2. æ¸²æŸ“ä¼˜åŒ–
```typescript
// è™šæ‹ŸåŒ–é•¿åˆ—è¡¨
import { FixedSizeList as List } from 'react-window';

const VirtualizedPrintTempList = ({ printTemps }: { printTemps: iPrintTemp[] }) => {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => (
    <div style={style}>
      <PrintTempCard printTemp={printTemps[index]} />
    </div>
  );
  
  return (
    <List
      height={600}
      itemCount={printTemps.length}
      itemSize={120}
    >
      {Row}
    </List>
  );
};
```

### 3. å†…å­˜ç®¡ç†
```typescript
// æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
useEffect(() => {
  const handleElementSelect = (elementId: string) => {
    setSelectedElement(elementId);
  };
  
  printTempsEventBus.on('element:select', handleElementSelect);
  
  return () => {
    printTempsEventBus.off('element:select', handleElementSelect);
  };
}, []);
```

## ğŸ”„ ç»„ä»¶é‡æ„è¯´æ˜

### ProductLabelPrinter â†’ TemplateBatchPrinter

**é‡æ„ç›®æ ‡**: å°†äº§å“ä¸“ç”¨çš„æ‰“å°ç»„ä»¶é‡æ„ä¸ºé€šç”¨çš„æ‰¹é‡æ‰“å°ç»„ä»¶

**ä¸»è¦å˜åŒ–**:
1. **ç»„ä»¶é‡å‘½å**: `ProductLabelPrinter` â†’ `TemplateBatchPrinter`
2. **æ³›å‹åŒ–**: ä½¿ç”¨ `<T>` æ³›å‹æ”¯æŒæ‰€æœ‰å®ä½“ç±»å‹
3. **æ¥å£é‡æ„**: 
   - `iProductLabelPrinterProps` â†’ `iTemplateBatchPrinterProps<T>`
   - `iPrintProductItem` â†’ `iPrintItem<T>`
4. **æ•°æ®æºä¼˜åŒ–**: 
   - `invoiceItems` â†’ `printItemsSource`
   - ç§»é™¤ `products` å±æ€§ï¼Œæ•°æ®åŒ…å«åœ¨ `printItemsSource` ä¸­
5. **æ˜¾ç¤ºé€»è¾‘è§£è€¦**: åœ¨ `iPrintItem<T>` ä¸­è®¾ç½® `id` å’Œ `name` å­—æ®µ
6. **ç§»é™¤APIè°ƒç”¨**: ä¸å†è°ƒç”¨ `productApi`ï¼Œç”±è°ƒç”¨æ–¹æä¾›å®Œæ•´æ•°æ®

**é‡æ„ä¼˜åŠ¿**:
- **é€šç”¨æ€§**: æ”¯æŒæ‰€æœ‰å®ä½“ç±»å‹ï¼Œä¸å†å±€é™äºäº§å“
- **è§£è€¦**: æ˜¾ç¤ºé€»è¾‘ä¸å®ä½“ç±»å‹è§£è€¦ï¼Œè°ƒç”¨æ–¹å®Œå…¨æ§åˆ¶
- **æ€§èƒ½**: ç§»é™¤ä¸å¿…è¦çš„APIè°ƒç”¨ï¼Œæå‡æ€§èƒ½
- **ç»´æŠ¤æ€§**: å•ä¸€ç»„ä»¶å¤„ç†æ‰€æœ‰æ‰¹é‡æ‰“å°éœ€æ±‚

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.1  
**åˆ›å»ºæ—¥æœŸ**: 2024-01-20  
**æœ€åæ›´æ–°**: 2024-01-20  
**ç»´æŠ¤è€…**: å‰ç«¯å›¢é˜Ÿ


